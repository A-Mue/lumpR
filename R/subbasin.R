# lumpR/subbasin.R
# Copyright (C) 2014-2018 Tobias Pilz
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' Calculation of hydrological subbasins using GRASS GIS
#' 
#' Takes DEM from a GRASS location and a file of drainage locations to calculate 
#' hydrological subbasins for each drainage point using GRASS functions.
#' 
#' @param dem Digital elevation model in GRASS location used for delineation of
#'      subbasins. Should be larger than the expected catchment, otherwise artefacts
#'      close to boundaries may occur.
#' @param drain_points \code{SpatialPoints} object containing drainage locations in
#'      units of and compliant with the projection of your respective GRASS location.
#'      Can be e.g. be imported from GRASS with
#'      drain_points = readVECT(vname = "subbas_outlets", layer=1)
#'      At least the watershed drainage point has to be given. If it contains the attribute 'subbas_id', this will be used for numbering the subbasins.
#' @param river River vector map in GRASS location if available. If set to \code{NULL}
#'      (default value) river network will be calculated by GRASS function \emph{r.watershed}.
#' @param flowaccum (optional) Existing raster map of flow accumulation in GRASS location. Must correspond to map generated by \code{r.watershed}.
#'      If \code{drainage_dir} or \code{flowaccum} is set to \code{NULL} (default value), both will be calculated by GRASS function \emph{r.watershed}.
#' @param drainage_dir (optional) Existing raster map of drainage direction in GRASS location. Must correspond to map generated by \code{r.watershed}.
#'      If \code{flowaccum} or \code{flowaccum} is set to \code{NULL} (default value), both will be calculated by GRASS function \emph{r.watershed}.
#' @param disk_swap (optional) Only needed if memory requirements exceed available RAM (large DEMs): If set to \code{TRUE}, \code{r.watershed} uses the "-m"-flag (slow)
#' @param basin_out Output: Name of subbasins raster map exported into GRASS location.
#' @param stream Output: Prefix of calculated stream segments vector (<stream>_vect) and
#'      raster (<stream>_rast) maps exported into GRASS location. Only generated if
#'      \code{river} is not set. Default: \code{NULL}.
#' @param points_processed Output: Prefix of point vector files exported to GRASS location.
#'      \code{<points_processed>_snap} are given \code{drain_points} snapped to river.
#'      \code{<points_processed>_calc} are internally calculated drain points (only if
#'      parameter \code{thresh_sub} is not \code{NULL}, see below).
#' @param outlet Integer (row number) defining the catchment outlet in \code{drain_points}.
#'      If there are \code{drain_points} outside the watershed delineated for the
#'      outlet point these will be omitted. If \code{NULL} (default) and \code{drain_points}
#'      contains only one point this will be assumed as catchment outlet.
#' @param thresh_stream Integer defining threshold for stream calculation. Raster
#'      cells in accumulation map with values greater than thresh_stream are
#'      considered as streams. Needs to be set only if \code{river} is not set.
#'      Default: \code{NULL}.
#' @param thresh_sub Integer defining threshold for subbasin calculation. Parameter for
#'      GRASS function \emph{r.watershed} defining the minimum size of an exterior
#'      watershed basin in number of grid cells. If \code{NULL} (default) only the
#'      given drainage points are used for subbasin delineation.
#' @param snap_dist Integer defining maximum distance for snapping of \code{drain_points}
#'      to stream segments in units of your GRASS location.
#' @param rm_spurious \code{numeric}. If greater zero, spurious subbasins will
#'      be removed, i.e. those subbasins being smaller than \code{rm_spurious} times \code{thresh_sub}.
#'      Spurious subbasins are 'interior' watersheds created by GRASS function
#'      \emph{r.watershed} around stream segments below multiple tributaries. If they
#'      are very small they induce unnecessary computational burden when used within a
#'      hydrological model. If removed, these areas will be related to the next upstream
#'      subbasins, respectively. If \code{thresh_sub = NULL} (default) \code{rm_spurious}
#'      will be automatically set to \code{0}. Default: 0.01.
#' @param keep_temp \code{logical}. Set to \code{TRUE} if temporary files shall be kept
#'      in the GRASS location, e.g. for debugging or further analyses. Default: \code{FALSE}.
#' @param overwrite \code{logical}. Shall output of previous calls of this function be
#'      deleted? If \code{FALSE} the function returns an error if output already exists.
#'      Default: \code{FALSE}.
#' @param silent \code{logical}. Shall the function be silent (also suppressing warnings
#'      of internally used GRASS functions)? Default: \code{FALSE}.
#'      
#'      
#' @note \bold{Prepare GRASS} location and necessary raster files in advance and start
#'      GRASS session in R using \code{\link[rgrass7]{initGRASS}}. Location
#'      should not contain any maps ending on *_t as these will be removed by
#'      calling the function to remove temporary maps.
#'      
#'      You should select your \bold{DEM sufficiently large}. Otherwise the resulting
#'      catchment might be truncated or boundaries influence the calculation
#'      of stream segments.
#'      
#'      \bold{Check the results} (subbasins and snapped points). In case points have been snapped
#'      to the wrong stream segment, adjust point locations manually in GRASS and re-run
#'      the function with the updated locations (use \code{\link[rgrass7]{readVECT}}
#'      to import the updated drainage points). Also check that calculated subbasins and
#'      those delineated based on given \code{drain_points} do not interfere (e.g.
#'      resulting in very small spurious subbasins).
#'      
#'      Generated raster and vector stream \bold{maps might slightly deviate} from each other
#'      as the raster map is thinned (GRASS function \emph{r.thin}) prior to conversion
#'      to a vector map to ensure strictly linear features.
#'      
#'      If you run into \bold{memory issues}, consider argument \code{disk_swap} (see also 
#'      \link[GRASS homepage]{https://grass.osgeo.org/grass74/manuals/r.watershed.html#in-memory-mode-and-disk-swap-mode})
#'      and see discussion on \link[lumpR's github page]{https://github.com/tpilz/lumpR/issues/16}.
#'      
#' @references 
#'      lumpR package introduction with literature study and sensitivity analysis:\cr
#'      Pilz, T.; Francke, T.; Bronstert, A. (2017): lumpR 2.0.0: an R package facilitating
#'      landscape discretisation for hillslope-based hydrological models.
#'      \emph{Geosci. Model Dev.}, 10, 3001-3023, doi: 10.5194/gmd-10-3001-2017
#' 
#' @author Tobias Pilz \email{tpilz@@uni-potsdam.de}

calc_subbas <- function(
  ### INPUT ###
  dem=NULL,
  drain_points=NULL,
  river=NULL,
  flowaccum=NULL,
  drainage_dir=NULL,
  disk_swap=FALSE,
  
  ### OUTPUT ###
  basin_out=NULL,
  stream=NULL,
  points_processed=NULL,
  
  ### PARAMETER ###
  outlet=NULL,
  thresh_stream=NULL,
  thresh_sub=NULL,
  snap_dist=NULL,
  rm_spurious=0.01,
  keep_temp=F,
  overwrite=F,
  silent=F
) {

### PREPROCESSING ###----------------------------------------------------------
  
  if(!silent) message("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")
  if(!silent) message("% START calc_subbas()")
  if(!silent) message("%")
  if(!silent) message("% Initialise function...")
  
  # CHECKS #
  tryCatch(gmeta(), error = function(e) stop("Cannot execute GRASS commands. Maybe you forgot to run initGRASS()?"))
  if(is.null(dem) | dem=="")
    stop("The name of a DEM within the mapset of your initialised GRASS session has to be given!")
  if(is.null(drain_points) | !grepl("SpatialPoints", class(drain_points)))
    stop("drain_points has to be given as SpatialPoints* object with at least one catchment outlet point!")
  if(is.null(river) & (is.null(thresh_stream | is.null(stream))))
    stop("If no river object is given, stream as name prefix for the generated stream maps and the parameter thresh_stream have to be specified for internal calculation of the river network!")
  if (identical(flowaccum,"")) flowaccum=NULL
  if (identical(drainage_dir,"")) drainage_dir=NULL
  if(xor(!is.null(flowaccum), !is.null(drainage_dir))) 
    stop("If using existing rasters flowaccum and drainage_dir, both have to be specified (or neither).")
  if(is.null(basin_out)  | basin_out=="")
    stop("You have to specify basin_out as name for the subbasin map to be generated!")
  if(is.null(points_processed))
    stop("You have to specify points_processed!")
  if(!is.numeric(snap_dist))
    stop("You have to specify snap_dist as a number!")
  if(is.null(outlet)) {
    if(nrow(drain_points@coords) > 1)
      stop("You have to give 'outlet' if the given number of drain_points is greater than one!")
    outlet <- 1
  }
  if(is.null(thresh_sub))
    rm_spurious <- 0
  if(!is.numeric(rm_spurious))
    stop("Argument 'rm_spurious' has to be numeric (behaviour changed in version 2.0.4)!")
  
  
  # CLEAN UP AND RUNTIME OPTIONS #  
  cmd_out <- execGRASS("g.version", intern=TRUE)
  if (cmd_out=="")
    stop("Couldn't connect to GRASS-session. Try removing any open sinks by calling 'sink()' repeatedly. Or restart R.")
  
   # suppress annoying GRASS outputs 
  tmp_file <- file(tempfile(), open="wt")
  sink(tmp_file, type="output")
  
 
  # also supress warnings in silent mode
  if(silent){
    tmp_file2 <- file(tempfile(), open="wt")
    sink(tmp_file2, type="message")
    oldw <- getOption("warn")
    options(warn = -1)
  }
  

### CALCULATIONS ###-----------------------------------------------------------
  tryCatch({
    
    # remove mask if there is any (and ignore error in case there is no mask)
    tryCatch(suppressWarnings(execGRASS("r.mask", flags=c("r"))), error=function(e){})
    
    # remove output of previous function calls if overwrite=T
    if (overwrite) {
      cmd_out <- execGRASS("g.remove", type="raster,vector", pattern=paste0("*_t,",stream,"_*,", basin_out, ",", points_processed, "_*"), flags=c("f", "b"), intern=T)
    } else {
      # remove temporary maps in any case
      cmd_out <- execGRASS("g.remove", type="raster,vector", pattern="*_t", flags=c("f", "b"), intern=T)
    }
    
    if(!is.null(flowaccum) )
    {
      # copy existing maps
      x <- execGRASS("g.copy", rast=paste0(flowaccum,",accum_t"), intern=TRUE, ignore.stderr = TRUE)
      x <- execGRASS("g.copy", rast=paste0(drainage_dir,",drain_t"), intern=TRUE, ignore.stderr = TRUE)
    }

    if(!silent) message("% OK")
    
    
  ### calc stream segments or use user defined input---------------------------
    if(is.null(river)) {
      if(!silent) message("%")
      if(!silent) message("% Calculate drainage and river network...")
      # GRASS watershed calculation #
      # flags to use for r.watershed
      if(disk_swap) {
        ws_flags <- c("overwrite","w", "s")
      } else {
        ws_flags <- c("overwrite", "s")
      }
      if(is.null(flowaccum) )
        execGRASS("r.watershed", elevation=dem, accumulation="accum_t", drainage="drain_t", flags = ws_flags)
      # check thresh_stream parameter
      cmd_out <- execGRASS("r.univar", map="accum_t", separator="comma", flags=c("t"), intern=TRUE, ignore.stderr = TRUE)

      cmd_out <- strsplit(cmd_out, ",")
      cmd_cols <- grep("^max$", cmd_out[[1]])
      max_acc <- as.numeric(cmd_out[[2]][cmd_cols])
      if(thresh_stream > max_acc)
        stop(paste0("Parameter 'thresh_stream' (", thresh_stream, ") is larger than the maximum flow accumulation within the study area (", max_acc, "). Choose a smaller parameter value!"))
      # calculate stream segments (don't use output of r.watershed as streams should be finer than generated therein)
      cmd_out <- execGRASS("r.mapcalc", expression=paste0(stream, "_rast = if(abs(accum_t)>", format(thresh_stream, scientific = F), ",1,null())"), intern=T)
      # thin
      cmd_out <- execGRASS("r.thin", input=paste0(stream, "_rast"), output=paste0(stream, "_thin_t"), iterations=10000, intern=T)
      # convert to vector
      cmd_out <- execGRASS("r.to.vect", input=paste0(stream, "_thin_t"), output=paste0(stream, "_vect"), type="line", intern=T)
      river <- paste0(stream, "_vect")
      
      if(!silent) message("% OK")
      
    } else {

      if(is.null(flowaccum) )
      {
        if(!silent) message("%")
        if(!silent) message("% Calculate drainage...")
        cmd_out <- execGRASS("r.watershed", elevation=dem, drainage="drain_t", flags = ws_flags, intern = T)
        if(!silent) message("% OK")
      }
    }
    
    
    
  ### calculate subbasins without given drainage points (optional)-------------
    if(is.numeric(thresh_sub)) {
      if(!silent) message("%")
      if(!silent) message("% Calculate subbasins based on given area threshold...")
      
      # calculate subbasins
      cmd_out <- execGRASS("r.watershed", elevation=dem, basin="basin_calc_t", threshold=thresh_sub, flags = ws_flags, intern=T)
      if(!silent) message("% OK")
    }
    
    
  ### snap given drainage points to streams------------------------------------
  if(!silent) message("%")
  if(!silent) message("% Snap given drainage points to streams...")
    

  ### ensure that given drainage points are NOT precisely at cell centres, because this may cause pathologic
  ### cases when snapping to streams (ending up at cell corners instead of cell interior)
    # add data slot and column subbas_id, if not given
    if(!any(slotNames(drain_points) == "data"))
      drain_points <- SpatialPointsDataFrame(drain_points, data=data.frame(subbas_id=1:length(drain_points)))
    if(!any(colnames(drain_points@data) == "subbas_id"))
      drain_points@data <- cbind(drain_points@data, subbas_id=1:length(drain_points))
    # force conversion to numeric 
    drain_points@data$subbas_id=as.numeric(as.character(drain_points@data$subbas_id)) 
    if (any(!is.finite(drain_points$subbas_id)))
        stop("The column 'subbasin_id' in drain_points contains non-numeric entries.")
    # write to GRASS
    suppressWarnings(proj4string(drain_points) <- CRS(getLocationProj()))
    suppressWarnings(writeVECT(drain_points, "dp_t", v.in.ogr_flags="o"))
    # WINDOWS PROBLEM: delete temporary file otherwise an error occurs when calling writeVECT or readVECT again with the same (or a similar) file name 
    if(.Platform$OS.type == "windows") {
      dir_del <- dirname(execGRASS("g.tempfile", pid=1, intern=TRUE, ignore.stderr=T))
      files_del <- grep(substr("dp_t", 1, 8), dir(dir_del), value = T)
      file.remove(paste(dir_del, files_del, sep="/"))
    }
    # move drainage points to centers of raster cells
    x <- execGRASS("v.to.rast", input="dp_t", output="dp_t", use="attr", attribute_column="subbas_id", flags="overwrite", intern=T)
    x <- execGRASS("r.to.vect", input="dp_t", output="dp_centered_t", type="point", flags = "overwrite")
    drain_points_centered <- readVECT(vname = "dp_centered_t", layer=1)
    colnames(drain_points_centered@data) <- c("subbas_id", "value")
    if(.Platform$OS.type == "windows") {
      dir_del <- dirname(execGRASS("g.tempfile", pid=1, intern=TRUE, ignore.stderr=T))
      files_del <- grep(substr("dp_centered_t", 1, 8), dir(dir_del), value = T)
      file.remove(paste(dir_del, files_del, sep="/"))
    }
    
    # determine raster resolution
    res <- gmeta()
    res <- sum(c(res$nsres, res$ewres)) / 2
    
    # create shifted version of drainage points (shifted by 1/4 of resolution)
    drain_points_shifted <- drain_points_centered
    drain_points_shifted@coords <- drain_points_shifted@coords + res/4
    suppressWarnings(writeVECT(drain_points_shifted, "dp_shifted_t", v.in.ogr_flags="o"))
    if(.Platform$OS.type == "windows") {
      dir_del <- dirname(execGRASS("g.tempfile", pid=1, intern=TRUE, ignore.stderr=T))
      files_del <- grep(substr("dp_shifted_t", 1, 8), dir(dir_del), value = T)
      file.remove(paste(dir_del, files_del, sep="/"))
    }
    
    drain_points <- drain_points_shifted
    rm(drain_points_shifted, drain_points_centered)
    
    # read stream vector
    cmd_out = execGRASS("v.info", map=river, intern=TRUE, ignore.stderr = TRUE)
    stat = attr(cmd_out, "status")
    if (!is.null(stat) && stat== 1)
      stop("River vector map ",river, " not found")
    
    streams_vect <- readVECT(river)
    # WINDOWS PROBLEM: delete temporary file otherwise an error occurs when calling writeVECT or readVECT again with the same (or a similar) file name 
    if(.Platform$OS.type == "windows") {
      dir_del <- dirname(execGRASS("g.tempfile", pid=1, intern=TRUE, ignore.stderr=T))
      files_del <- grep(substr(river, 1, 8), dir(dir_del), value = T)
      file.remove(paste(dir_del, files_del, sep="/"))
    }
  
    # snap points to streams
    drain_points_snap <- suppressWarnings(snapPointsToLines(drain_points, streams_vect, maxDist=snap_dist))
    drain_points_snap$nearest_line_id=NULL #we don't need this and this long filed name causes trouble
    
    if (length(drain_points_snap) < length(drain_points)) stop("Less points after snapping than in drain_points input!\nComputed stream segments are probably are too coarse. Try a smaller value of thresh_stream to create a fine river network.")
    
    # export drain_points_snap to GRASS
    suppressWarnings(writeVECT(drain_points_snap, paste0(points_processed, "_snap"), v.in.ogr_flags = "o"))
    # WINDOWS PROBLEM: delete temporary file otherwise an error occurs when calling writeVECT or readVECT again with the same (or a similar) file name 
    if(.Platform$OS.type == "windows") {
      dir_del <- dirname(execGRASS("g.tempfile", pid=1, intern=TRUE, ignore.stderr=T))
      files_del <- grep(substr(paste0(points_processed, "_snap"), 1, 8), dir(dir_del), value = T)
      file.remove(paste(dir_del, files_del, sep="/"))
    }
    
    if(!silent) message("% OK")
    
    
  ### calculate catchments for every drainage point----------------------------
    if(!silent) message("%")
    if(!silent) message("% Calculate catchments for every drainage point...")
    
    # update index to outlet, as its order may have changed during previous steps
    outlet <- which(drain_points_snap@data$subbas_id == drain_points@data$subbas_id[outlet])
    outlet_coords <- coordinates(drain_points_snap)[outlet,]

    cmd_out <- execGRASS("r.water.outlet", input="drain_t", output=paste0("basin_outlet_t"), coordinates=outlet_coords, intern = T)
    cmd_out = execGRASS("r.stats", input=paste0("basin_outlet_t"), flag=c("c","n","quiet"), intern = TRUE)
    ncells = as.numeric(strsplit(cmd_out, split = " ")[[1]][2])
    if (!is.finite(ncells) | ncells < 100)
      stop(paste0("Number of cells in calculated catchment is very low (",ncells,"). Try using a filled DEM or correcting this point."))
    
    # get drainage points of calculated subbasins (optional)
    if(is.numeric(thresh_sub)) {
      
      # set watershed of outlet point as mask
      cmd_out <- execGRASS("r.mask", raster="basin_outlet_t", intern = T)
      
      # the following calculations only make sense if thresh_sub is small enough to produce more subbasins than determined by drain_points
      no_catch_calc <- length(as.numeric(execGRASS("r.stats", input="basin_calc_t", flags=c("n"), intern=T, ignore.stderr = T)))
      if(no_catch_calc > 1) {
        
        # read raster data from GRASS for processing
        basins <- raster(readRAST("basin_calc_t", ignore.stderr = T))
        accum <- raster(readRAST("accum_t", ignore.stderr = T))
        
        # calculate zonal statistics: Maximum accumulation for every subbasin (=outlet)
        stats <- zonal(accum, basins, fun="max")
        
        # remove calculated watershed outlet (point of maximum flow accumulation) as this has been given as input
        stats <- stats[-which(stats[2] == max(stats[2])), ]
        
        # get coordinates of outlets
        outs <- apply(stats, 1, function(x) {
          cell_no <- Which(accum==x[2], cells=T)
          
          # if there is more than one cell, get the one in the right subbasin
          if(length(cell_no) > 1) {
            cell_bas <- Which(basins==x[1], cells=T)
            cell_no <- cell_no[which(cell_no %in% cell_bas)]
          }
          
          # get coordinates of cell_no
          res <- round(xyFromCell(accum, cell_no),0)
          res <- cbind(res, x[1])
          return(res)
        })
        
        # delete raster objects
        rm(accum, basins)
        gc(verbose = F); gc(verbose = F)
        
        # re-arrange data
        outs <- t(outs)
        colnames(outs) <- c("x", "y", "cat")
        outs <- as.data.frame(outs)
        coordinates(outs) <- c("x", "y")
        
        # as SPDF
        drain_points_calc <- SpatialPointsDataFrame(coordinates(outs), outs@data, proj4string = CRS(getLocationProj()))
        
        # write to GRASS location
        writeVECT(drain_points_calc, paste0(points_processed, "_calc"), ignore.stderr = T, v.in.ogr_flags = "o")
        
        # df should only contain a cat column
        drain_points_snap@data <- data.frame(cat=1:nrow(drain_points_snap@data))
        suppressWarnings(proj4string(drain_points_snap) <- CRS(getLocationProj()))
        
        # merge with existing drain points object (snapped points first as there the outlet is identified)
        drain_points_snap <- rbind(drain_points_snap, drain_points_calc)
        
      } # more than one subbasin
      
      # remove mask
      cmd_out <- execGRASS("r.mask", flags=c("r"), intern = T)
    }
    
    if (any(duplicated(drain_points@data$subbas_id))) 
    {  
      warning("Duplicated subbas_id in drainage points. Ignoring IDs, using row numbers instead.")
      drain_points@data$subbas_id=NULL 
    }
    # loop over drainage points of subbasins TODO: This step is slow!
    for (p in 1:length(drain_points_snap)) {

      # outlet coordinates
      outlet_coords <- coordinates(drain_points_snap)[p,]

      # basin
      cmd_out <- execGRASS("r.water.outlet", input="drain_t", output=paste0("basin_", p, "_t"), coordinates=outlet_coords, intern = T)
      
      cmd_out = execGRASS("r.stats", input=paste0("basin_", p, "_t"), flag=c("c","n","quiet"), intern = TRUE)
      ncells = as.numeric(strsplit(cmd_out, split = " ")[[1]][2])
      if (!is.finite(ncells) | ncells < 100)
        warning(paste0("Number of cells in calculated catchment ",p," is very low (",ncells,"). Try using a filled DEM and check outlet points."))


      # reclass (subbasins gets number of i for crossing later)
      if (!is.na(drain_points@data$subbas_id[p])) {
        id = drain_points@data$subbas_id[p]
      } else { #use specified ID, if available
        id = p
      }
      cmd_out <- execGRASS("r.mapcalc", expression=paste0("basin_recl_", p, "_t = if(basin_", p, "_t,", id, ")"), intern=T)
      
    }

    no_catch <- p
    
    if(!silent) message(paste("% -> Identified", no_catch, "subbasins."))
    if(!silent) message("% OK")
  
    

  ### merge all sub-catchments-------------------------------------------------
    if(!silent) message("%")
    if(!silent) message("% Merge calculated catchments...")

    # put sub-catchments together
    #subcatch_rasts <- execGRASS("g.mlist", type="rast", pattern=paste0("basin_recl_[0-9]*_t"), intern=T)
    subcatch_rasts <- paste0("basin_recl_",1:no_catch, "_t")
    
    # if more than one sub-catchment
    if(no_catch > 1) {
      
      # drain points needed as raster
      suppressWarnings(writeVECT(drain_points_snap, paste0(points_processed, "_all_t"), v.in.ogr_flags = "o"))
      # WINDOWS PROBLEM: delete temporary file otherwise an error occurs when calling writeVECT or readVECT again with the same (or a similar) file name 
      if(.Platform$OS.type == "windows") {
        dir_del <- dirname(execGRASS("g.tempfile", pid=1, intern=TRUE, ignore.stderr=T))
        files_del <- grep(substr(paste0(points_processed, "_all_t"), 1, 8), dir(dir_del), value = T)
        file.remove(paste(dir_del, files_del, sep="/"))
      }
      x <- execGRASS("v.to.rast", input=paste0(points_processed, "_all_t"), output=paste0(points_processed, "_all_t"), use="cat", flags="overwrite", intern=T)
      
      # iterate until configuration without 'spurious' sub-catchments is found (if rm_spurious > 0) TODO: This step is slow in case many iterations are needed!
      while (TRUE) {
      
        # max 30 maps at once, create multiple cross products if necessary
        x <- execGRASS("g.remove", type="raster", pattern="basin_cross_*", flags="f", intern=T) # remove old basin_cross_*
        iterations <- ceiling(length(subcatch_rasts)/30)
        for (j in 1:iterations){
          if (j == iterations) {
            if(length(subcatch_rasts) %% 30 == 1) {
              x <- execGRASS("g.copy", raster=paste(subcatch_rasts[((j-1)*30+1):length(subcatch_rasts)], paste0("basin_cross_", j, "_t"), sep=","), 
                             intern=T, ignore.stderr=T)
            } else {
              x <- execGRASS("r.cross", input=paste(subcatch_rasts[((j-1)*30+1):length(subcatch_rasts)], collapse=","),
                             output=paste0("basin_cross_", j, "_t"), flags = c("overwrite"), intern=T, ignore.stderr=T)
            }
          } else {
            x <- execGRASS("r.cross", input=paste(subcatch_rasts[((j-1)*30+1):(j*30)], collapse=","),
                           output=paste0("basin_cross_", j, "_t"), flags = c("overwrite"), intern=T, ignore.stderr=T)
          }
        }
        
        # x <- execGRASS("r.patch", input=paste(subcatch_rasts, collapse=","), #r.patch does not work under windows
        #                output=paste0("basin_cross_", j, "_t"), flags = c("overwrite"), intern=T, ignore.stderr=T)
        # 
    
        # simply adding up does not do the job as intermediate basins will overwrite headwater basins
        # x <- execGRASS("g.remove", rast="basin_all_t", intern=T, ignore.stderr=T)
        # x <- execGRASS("g.copy", rast=paste0(subcatch_rasts[1],",", "basin_all_t"), intern=T, ignore.stderr=T)
        # 
        # for (j in 2:length(subcatch_rasts))
        # {
        #     execGRASS("r.mapcalculator", amap="basin_all_t", bmap=subcatch_rasts[j], outfile=basin_out,
        #               formula="if(isnull(A),0,A) + if(isnull(B),0,B)", flags = "overwrite")
        #     x <- execGRASS("g.copy", rast=paste0(basin_out,",", "basin_all_t"), intern=T, ignore.stderr=T)
        # } 
          
        
        
        # merge cross products
        cross_rasts <- execGRASS("g.list", type="raster", pattern=paste0("basin_cross_[0-9]*_t"), intern=T)

        if(length(cross_rasts) == 1) {
          x <- execGRASS("g.rename", raster=paste(cross_rasts, "basin_all_t", sep=","), intern=T, ignore.stderr=T)
        } else {
          x <- execGRASS("r.cross", input=paste(cross_rasts,collapse=","), output="basin_all_t",
                    flags = c("overwrite"), intern=T, ignore.stderr=T)
        }
        
        # check for and correct error in r.cross, see https://lists.osgeo.org/pipermail/grass-user/2018-February/077934.html
        cmd_out <- execGRASS("r.stats", input="basin_all_t", flags=c("n"), intern=T, ignore.stderr = T)
        if(any(as.numeric(cmd_out) == 0)) {
          cmd_out <- execGRASS("r.mapcalc", expression="basin_all_t=basin_all_t+1", flags=c("overwrite"), intern=T)
        }
        
        # check size of sub-catcments and identify and remove 'spurious' sub-catchments
        if(rm_spurious>0) {
          # get sub-catcments and sizes (cell counts) and identify spurious ones
          cmd_out <- execGRASS("r.stats", input="basin_all_t", flags=c("n", "c"), intern=T, ignore.stderr = T)
          sub_sizes <- matrix(as.numeric(unlist(strsplit(cmd_out, " "))), ncol=2, byrow=T)
          #sub_sizes <- sub_sizes[-which(sub_sizes[,1] == 0),]
          sub_rm <- sub_sizes[which(sub_sizes[,2] < rm_spurious*thresh_sub),1]
          if(length(sub_rm)>0) {
            # get number of basin_recl_* to be romved (not identical with raster values of basin_all_t!)
            cmd_out <- execGRASS("r.univar", map=paste0(points_processed, "_all_t"), zones="basin_all_t", separator="comma", flags=c("t"), intern=T, ignore.stderr = T)
            cmd_out <- strsplit(cmd_out, ",")
            cmd_cols <- grep("zone|^mean$", cmd_out[[1]])
            basins_points <- do.call(rbind, cmd_out)[-1,cmd_cols, drop=F]
            sub_rm_f <- as.numeric(basins_points[which(as.numeric(basins_points[,1]) %in% sub_rm),2])
            # remove this temporary map from processing and try again (back to start of while loop)
            subcatch_rasts <- grep(paste0("basin_recl_", sub_rm_f, "_t", collapse="|"), subcatch_rasts, invert = T, value = T)
            x <- execGRASS("g.remove", type="raster", name="basin_all_t", flags = "f", intern=T)
            # update no_catch
            no_catch <- no_catch - length(sub_rm_f)
          } else {
            break
          }
        } else {
          break # exit while loop
        }
      
      } # end while-loop
      
      # constrain to catchment of outlet point
      cmd_out <- execGRASS("r.mapcalc", expression=paste0(basin_out, " = basin_outlet_t * basin_all_t"), intern=T)
      
      
    } else { # only one sub-catchment
      
      if(no_catch == 0)
        stop("Number of identified sub-catchments is zero. Check input data!")
    }



    # TODO: Only works for special cases where all subbasin-ids were pre-specified. Needs to be generalised!
    # # reclass automatically-created subbasin-ids to those that were used originally
    # cmd_out = execGRASS("v.db.addcolumn", map=paste0(points_processed, "_snap"), columns="temp_id integer", ignore.stderr = T, intern = TRUE) #add column for taking up new id
    # stat = attr(cmd_out, "status")
    # if (!is.null(stat) && stat== 1)
    #   stop(paste("Could not add column to", drain_points_snap, ".", sep=" "))
    # cmd_out = execGRASS("v.what.rast", raster="basin_all_t", map=paste0(points_processed, "_snap"), column="temp_id" ,intern=T, ignore.stderr = T)
    # stat = attr(cmd_out, "status")
    # if (!is.null(stat) && stat== 1)
    #   stop("Could not update column to drain_points_snap.")
    # drain_points = readVECT(vname = paste0(points_processed, "_snap"), layer=1) #re-import vector layer containing new IDs
    # rules <- paste0(drain_points$temp_id,"=",drain_points$subbas_id, collapse="\n")
    # tempfile=tempfile()
    # write(rules, file=tempfile)
    # cmd_out = execGRASS("r.reclass", input="basin_all_t", output="basin_all2_t", rules=tempfile, flags="overwrite", intern=T)
    # unlink(tempfile)
    # stat = attr(cmd_out, "status")
    # if (!is.null(stat) && stat== 1)
    #   stop("Could not reclassify subbasin-map.")
    # 
    # execGRASS("g.rename", raster=paste("basin_all2_t", basin_out, sep=","))
    
      
    # set values of zero to NULL
    execGRASS("r.null", map=basin_out, setnull="0")
    
    no_cross <- length(execGRASS("r.stats", input=basin_out, flags=c("n"), intern=T, ignore.stderr = T))
    if(no_catch != no_cross) warning(paste0("\nNumber of categories in ", basin_out, " not equal to number of drainage points!\nThis might be because there are drainage points outside the catchment of the defined outlet or due to small inconsistencies between calculated and manually defined (and snapped) drainage points. However, you should check the output with the GRASS GUI and consider the help pages of this function. 
                                            Try correcting the drainage points manually by running 'v.digit map=drain_points_snap bgcmd=d.rast stream_accum_rast'"))
    
    
    
    # remove temporary maps
    if(keep_temp == FALSE)
      execGRASS("g.remove", type="raster,vector", pattern="*_t", flags=c("f"))
    
    
    if(!silent & rm_spurious > 0) message(paste("% -> Checked for spurious subbasins; ", no_catch, "subbasins left."))
    if(!silent) message("% OK")
    if(!silent) message("%")
    if(!silent) message("% -> Check the results for plausibility (e.g. inaccuracies at snapping of drain_points to streams may occur).")
    if(!silent) message("% -> If manual adjustments are necessary re-run the function for re-calculation of subbasins.")
    if(!silent) message("%")
    if(!silent) message("% DONE!")
    if(!silent) message("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")
    
    
    # stop sinking
    closeAllConnections()
    
    # restore original warning mode
    if(silent)
      options(warn = oldw)


    
    
  # exception handling
  }, error = function(e) {
    
    # stop sinking
    closeAllConnections()
    
    # restore original warning mode
    if(silent)
      options(warn = oldw)
    
    # remove mask if there is any (and ignore error in case there is no mask)
    cmd_out <-tryCatch(suppressWarnings(execGRASS("r.mask", flags=c("r"), intern = T)), error=function(e){})
    
    if(keep_temp == FALSE)
      cmd_out <- execGRASS("g.remove", type="raster,vector", pattern=paste0("*_t,",stream,"_*,", basin_out, ",", points_processed, "_*"), flags=c("f", "b"), intern = T)
    
    stop(paste(e))  
  })
  

} # EOF
